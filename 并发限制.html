<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    class ConcurrentControl{
        constructor(maxConcurrent){
            this.maxConcurrent=maxConcurrent // 最大并发数
            this.running=0 //当前运行的任务数
            this.queue=[] //等待队列
        }

        //加入队列并触发执行
        //task 是一个函数，调用它会返回一个 Promise（异步）
        add(task){
            //目的：让调用 add 的地方能拿到一个 Promise，可以 await 或 .then() / .catch()
            return new Promise((resolve,reject)=>{
                this.queue.push({
                    task, //实际要执行的任务函数
                    //当任务完成（或者失败）时，可以用这个 resolve/reject 来通知调用者
                    resolve, //外层 Promise 的成功回调
                    reject
                })
                this.run()
            })
        }

        // 执行任务，包含执行逻辑
        run(){
            // 如果达到最大并发数或没有任务，直接返回
            if(this.running >= this.maxConcurrent || this.queue.length === 0){
                return
            }
            //取出第一个任务，是为了 按顺序执行队列里的任务
            const {task,resolve,reject} = this.queue.shift()
            this.running++

            //task() → 执行任务函数，返回一个 Promise
            Promise.resolve(task())
            .then(resolve)
            .catch(reject)
            //减少当前运行任务数，并尝试执行下一个队列任务
            .finally(()=>{
                this.running--
                this.run() // 尝试执行下一个任务
            })
        }
    }

    // 使用示例
    const controller = new ConcurrentControl(3); // 最大并发数为3

    // 模拟异步任务
    function asyncTask(id, delay) {
        return () => new Promise(resolve => {
            console.log(`任务 ${id} 开始`);
            setTimeout(() => {
            console.log(`任务 ${id} 完成`);
            resolve(id);
            }, delay);
        });
    }

    // 添加多个任务
    for (let i = 1; i <= 10; i++) {
        //返回一个 0（包含）到 1（不包含） 的随机小数
        controller.add(asyncTask(i, Math.random() * 2000));
    }
</script>
</html>