<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    //存和取数据，过期自动删除
    //对缓存进行全面管理：存储、读取、删除、清理过期数据、缓存状态统计、清除所有缓存
class RequestCache {
  constructor(defaultTTL = 300000) { // 默认5分钟TTL
    this.cache = new Map();  //map存缓存数据
    this.defaultTTL = defaultTTL; // TTL：Time To Live（缓存生存时间）
  }

  // 生成缓存键：确保同一请求唯一可识别
  // url:请求的地址
  // params：表示请求参数（通常是查询参数或 body 参数），是一个对象
  generateKey(url, params = {}) {
    // 对参数按 key 排序，避免同样参数顺序不同造成缓存不一致
    //Object.keys(params) 会返回一个数组，包含 params 对象中所有的 键名。
    const sortedParams = Object.keys(params)
      .sort()  //默认会按照字符串的字典序（即字母表顺序）来排序
      .reduce((acc, key) => {
        acc[key] = params[key];
        return acc; //每次遍历返回一次，如果不返回则累计失效，下一次遍历接收到上一次的acc
      }, {});
      //第二个参数是初始值，也就是空对象，acc累计结果，key是当前遍历到的键名
      //每一轮都把对应的key和params[key]添加到新对象中
      //最后返回acc，它也是一个对象
    
      // 返回唯一键名，例如 "api/data:{"page":1,"size":10}"
    return `${url}:${JSON.stringify(sortedParams)}`;
  }

  // 数据存入缓存
  // key是前面生成的唯一键名
  // data是要缓存的真实数据，任意类型
  // 存这个cache，的value包括，data，过期时间（=data.now()+ttl）和创建时间
  set(key, data, ttl = this.defaultTTL) {
    const expiresAt = Date.now() + ttl; // 计算过期时间戳
    this.cache.set(key, {
      data,             // 实际缓存的数据
      expiresAt,        // 何时过期
      timestamp: Date.now() // 创建时间（方便统计）
    });
    
    // 每次写入时顺便清理已过期的缓存
    this.cleanup();
  }

  // 根据缓存键获取缓存数据，分为没缓存/有但已过期/未过期
  get(key) {
    // 从 Map 中取
    const item = this.cache.get(key);
    
    // 没有缓存 → 返回 null
    if (!item) return null;
    
    // 如果已过期，删除并返回 null
    if (Date.now() > item.expiresAt) {
      this.cache.delete(key);
      return null;
    }
    
    // 未过期 → 返回缓存数据
    return item.data;
  }

  // 删除缓存
  delete(key) {
    return this.cache.delete(key);
  }

  // 清理所有过期缓存
  cleanup() {
      const now = Date.now();
      // 遍历整个 Map，删掉过期项
      //this.cache.entries()返回一个可迭代对象，包含map所有键值对
    for (const [key, value] of this.cache.entries()) {
      if (now > value.expiresAt) {
        this.cache.delete(key);
      }
    }
  }

  // 获取缓存统计，先清理过期的，size和keys（转化为数组）
  getStats() {
    this.cleanup(); // 先清理过期的，保证数据准确
    return {
      size: this.cache.size,  // 当前有效缓存数量
      keys: Array.from(this.cache.keys())  // 当前缓存的所有 key
    };
  }

  // 清空所有缓存
  clear() {
    this.cache.clear();
  }
}

// 带缓存的fetch封装
//请求和用缓存
//每次请求前，先去缓存层查有没有旧数据
// → 有就直接返回
// → 没有就真的发请求
// 如果同一个接口正在请求中，就等它完成（防止重复请求）
// 请求成功后，把结果存进缓存（带TTL）

class CachedFetcher {
  constructor() {
    this.cache = new RequestCache();
    this.pendingRequests = new Map(); // 存放“正在请求中的”接口，防止重复请求
  }

  // 核心请求方法
  // 用来传递请求的可选配置，比如 HTTP 方法、请求头、请求体、缓存时间等
  // 注意这里没有function, 因为类的方法默认就是函数
  async fetch(url, options = {}) {
    const { ttl, ...fetchOptions } = options;// ttl 单独取出，其余传给 fetch
    const key = this.cache.generateKey(url, fetchOptions); // 根据参数生成唯一 key

    // 步骤1：先查缓存，有则直接返回
    const cached = this.cache.get(key);
    if (cached) {
      console.log('从缓存获取数据:', url);
      return cached;
    }

    // 步骤2：如果该请求已经在进行中，等待它完成（防止多次并发相同请求）
    if (this.pendingRequests.has(key)) {
      console.log('等待相同请求完成:', url);
      return await this.pendingRequests.get(key);
    }

    // 步骤3：真正发请求，原生API，用于发http请求，返回一个promise
    const request = fetch(url, fetchOptions)
      .then(response => {
        // 检查返回状态码，不正常就抛错
        // response.ok 为 true：HTTP 状态码在 200~299 之间 → 请求成功
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        // 转成 JSON
        return response.json();
      })
      .then(data => {
        // 步骤4：请求成功后写入缓存
        // 这里的cache是一个RequestCache对象，里面的set定义了三个参数
        this.cache.set(key, data, ttl);
        return data;
      })
      .finally(() => {
        // 步骤5：无论成功或失败，都要清除“正在请求”状态
        this.pendingRequests.delete(key);
      });

    // 将该请求存入 pendingRequests，标记它正在进行中
    // 这是主线程，，
    this.pendingRequests.set(key, request);

    // 返回结果（等待该请求完成）
    return await request;
  }

  // 删除指定接口的缓存
  clearCache(url, params = {}) {
    const key = this.cache.generateKey(url, params);
    return this.cache.delete(key);
  }

  // 获取缓存状态（调试/展示用）
  getCacheStats() {
    return this.cache.getStats();
  }

  // 清空所有缓存与进行中的请求
  clearAllCache() {
    this.cache.clear();
    this.pendingRequests.clear();
  }
}
// 示例使用

const fetcher = new CachedFetcher();

async function demo() {
  try {
    // 第一次请求：会真的发网络请求
    console.log('第一次请求:');
    const data1 = await fetcher.fetch('https://api.example.com/data', {
      ttl: 60000 // 缓存 1 分钟
    });

    // 第二次请求：命中缓存，不再请求服务器
    console.log('第二次请求:');
    const data2 = await fetcher.fetch('https://api.example.com/data');

    // 查看缓存状态
    console.log('缓存状态:', fetcher.getCacheStats());
  } catch (error) {
    console.error('请求失败:', error);
  }
}
// demo()
// 导出以便其他模块使用
// export { RequestCache, CachedFetcher };

</script>
</html>